# CH 11. 프록시 패턴

### 프록시 패턴이란?
- 특정 객체로의 접근을 제어하는 대리인
- 제어한다는 의미는 동일하지만, 다양한 용례가 있다.
- 구현아이디어는 간단하다. : Subject를 구현한 클래스의 참조값을 갖는 Proxy 클래스를 만들어서, Proxy 클래스에서 Subject의 메소드를 호출하고, 그 결과를 반환한다.
- 키워드는 호출을 중간에서 가로챈다. 는 측면에서 키워드가 있다. 프록시의 변종이 많은데, 변종들은 이 키워드를 기반으로 한다.

### 프록시 패턴의 종류
- 원격 프록시 : 다른 JVM에 존재하는 객체에 대한 접근을 관리한다.
- 가상 프록시 : 비용이 많이 드는 객체를 필요할 때까지 생성하지 않고, 가상으로 생성해서 사용한다.
- 보호 프록시 : 클라이언트의 권한에 따라 메소드 호출을 제어

### 원격 프록시 예제 : RMI
- RMI (Remote Method Invocation)
- 프록시가 네트워크 통신을 통해 원격 객체를 호출하는 과정의 복잡한 프로세스를 처리한다.
- 혁님 : 일반적인 용례는 아니지만, RMI는 프록시 패턴의 대표적인 구현이라고 생각한다.
- 한계점 : 무조건 자바환경에서만 가능 / 폐쇄망에선 사용할 수 있는 것 같다.


### 가상 프록시
- 진짜 객체가 필요한 상황이 오기 전까지 비용이 큰 객체의 생성을 미룬다.
- 프록시 패턴의 많은 용례가 가상 프록시에 속하는 케이스

### 프록시 패턴과 다른 패턴의 관계
- 프록시 vs 데코레이터 패턴
  - 데코레이터 패턴의 용도 : 객체에 새로운 책임을 추가할 때 사용한다.
    - 예성님 : 형태가 비슷한데, 차이점은 사용용도에 따라 나뉘고, 데코레이터는 여러개 중첩해서 사용하기 좋다.
    - Spring JPA 연관관계의 경우 Lazy Loading을 하면서 '객체의 생명주기를 관리한다'는 측면에도 차이가 있다.
    - 혁님 : 그러나 두 패턴의 용도가 헷갈리기 쉬운것 같다.
    - 예성님 : Lazy Decorator라는 구현도 보았다.
  그만큼 프록시가 많이 활용되고, 변종이 많다는 것을 알 수 있다. 

### 프록시 vs 어댑터 패턴
- 어댑터 패턴의 용도 : 인터페이스가 다른 두 객체를 연결해 다른 인터페이스를 지원하도록
- 보호 프록시 패턴은 객체의 접근을 제한하기 때문에 클라이언트에게 일부분만 제공할 수 있다는 측면에서 유사


### 프록시 패턴의 활용
- JPA Hibernate : 가상 프록시 패턴
  - 엔티티 조회 시 연관관계를 맺은 Lazy 클래스는 프록시를 가지고, 실제 값이 들어있지 않다.

- Spring AOP : 횡단관심사를 프록시로 처리
  - 전후에 프록시를 끼워서 횡단관심사를 처리한다. ex) 로깅

+ **NestJS에서도 DI의 형태를 사용한다.**
- 코드내에서 각자 인스턴스화하는 대신 IoC 컨테이너(NestJS) 런타임 시스템)로 위임한다.

### 프록시 패턴 사용시 주의할 점
- 스프링에서 프록시 객체를 주입받아 사용하는데, Transaction이 걸려있지 않는 메소드에서 Transaction이 걸린 객체를 호출하면 문제가 발생할 수 있다.
  - 트랜잭션이 걸리지 않은 메소드 A에서 트랜잭션이 걸린 메소드 B를 호출하면, B 메소드의 트랜잭션 설정이 A 메소드에 영향을 미치지 않는다. 즉, B 메소드에서 발생하는 데이터베이스 연산은 A 메소드의 트랜잭션 범위에 포함되지 않는다.
  - 스프링에서는 @Transaction(readonly=true)를 사용해 읽기 경우에는 미연에 방지하고자 한다.
