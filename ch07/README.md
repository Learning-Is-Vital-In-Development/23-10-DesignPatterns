# CH 07. 어댑터 패턴과 퍼사드 패턴

## 발표자료
### 어댑터 패턴이란?  

- 기존 시스템과 호환되지 않는 특정 클래스의 인터페이스를 기존 시스템에서 호환되는 형식으로 변환해 사용하는 패턴  
    - 호환과 변환이라는 단어에 어댑터 패턴의 중요한 의미가 담겨있다.
- 코드 RegacySystemInterface를 NewSystemAdaptor가 기능을 호출해 변환해주면서 사용

### 객체 어댑터 패턴 vs 클래스 어댑터 패턴 

- 객체 어댑터 : 컴포지션 이용
- 클래스 어댑터 : 타겟과 어댑티를 모두 상속받아 사용(다중상속의 형태)

### 퍼사드패턴이란?
- 인터페이스를 덮어씌워서 사용하기 형태 
- 기능들이 복잡해서 단순하게 만들기 위해 변환하는 패턴 (어댑터패턴과의 차이)
- 여러개의 서브시스템을 하나의 추상화된 레이어를 만들어 사용함 

### 최소 지식의 원칙  

- 객체 사이의 사용작용은 아주 가까운 친구 사이에만 허용하자.
    - 다른 메소드를 호출해서 리턴받은 객체의 메소드를 사용하지 말자.
- 최소 지식의 원칙을 지양할 항목 4가지로 구체화 해보자.  

### 지양할 항목  

- 체이닝 메소드 : System.out.println
- 임시 필드 : 클래스의 필드가 특정 상황에만 값을 갖고 그 외의 상황에는 null 또는 기본 값 혹은 임의의 값을 가지는 것.
- 과도한 정보 공개 : 정보를 각각 제공하기 보다는 하나의 객체로 제공하기
- 클래스 내부 구현 노출 : public 필드 대신 getter, setter 사용

### 어댑터 패턴 vs 데코레이터 패턴  

- 목적의 차이이다.
- 데코레이터 패턴도 객체를 래핑해서 사용하는 형태여서 공통점이 있다.
- 데코레이터는 객체의 책임과 행동을 확장하기 위해 사용한다.
- 어댑터는 인터페이스를 변환한 것 

## 궁금한 점

### 예성님 : 클래스어댑터도 결국엔 컴포지션 형태로 운용하지 않나?

- 객체어댑터는 인터페이스를 상속받기 때문에 여러개의 메소드를 구현해야만하는 강제성.
- 클래스어댑터는 구현체를 상속받기 때문에, 오버라이딩을 강제받지 않는다는 유연성이 있다.
- 클래스어댑터의 장점을 살리고 싶을때 쓰면 좋을 것같다.


### 최소 지식의 원칙 중 메소드를 생성한다는 의미가 무엇일까?
- 예성님 : 체이닝메소드를 쓰지 말라는 의미로 받아들임 

### 데코레이터도 변환의 의미를 가지지 않는가? 

- 데코레이터가 기능을 덧붙이면서 변환의 의미를 가진다. 
- 혁님 : 행동에 대한 다른 부가적인 객체를 만들기 때문에 확장이라는 개념이 뚜렷하게 있다고 생각한다. 
- 두 패턴은 공통점이 있지만 사용목적에서 차이가 있다.

### 예성님 : 어댑터 패턴의 실제 예시가 뭐가 있을까?

- 혁님 : 레거시를 그대로 두고 새로운 인터페이스를 만드는게 어댑터가 의미가 있다. 그러나 기존의 코드를 수정하는게 더 좋다고 생각한다.
- 스프링의 HandlerAdaptor

### 혁님 : 퍼사드 패턴의 바운더리?

- 퍼사드 패턴은 일련의 행위를 추상화 해 하나로 제공한다. 클라이언트의 의존성이 줄어든다는 측면에서 의미가 있다. 
- 여러개의 검증 로직을 하나로 묶어서 하나의 레이어를 추가해 제공한다면 그것도 퍼사드패턴이라고 할 수 있을까?
    - 예성님 : 관심이 분리되어 있고, 서브시스템을 묶어 추상화해서 제공했기 때문에 퍼사드라고 볼 수 있을 것 같다.  

### 예성님 : 퍼사드 vs 전략  

- 전략은 다양한 전략을 갈아 끼우는 용례이고, 퍼사드는 서비스를 모아서 처리해야하는 경우에 쓴다.
