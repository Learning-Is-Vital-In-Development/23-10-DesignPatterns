# CH 12. 복합 패턴

## 발표자료 : 예성님 발표

- MVC 패턴은 주로 사용자 인터페이스를 가진 애플리케이션 개발에 적용가능
- Model
- View
- Controller

### 책에 나온 예시 : 오리 시뮬레이터 

- Model : 옵저버 패턴
- View : 컴포지트 패턴
- Controller - View 사이  : 전략패턴


### 백엔드에서의 MVC 패턴
- 모델 : 직접 데이터 베이스와 상호작용
- 컨트롤러 : 사용자로부터의 요청을 받아 처리하고, 적절한 응답을 반환, 비즈니스 로직 로직

>  View는 어디에 있나요?
> 백엔드의 MVC 패턴에서 "View" 흔히 프론트에서 보는 화면을 의미하지만, 백엔드에서의 "View"는 클라이언트에게 보내는 응답 형식을 의미한다.

### Django 프레임워크의 MVT 패턴
- MVC에서 변형된 패턴

- Model : 데이터베이스와 상호작용
- View : MVC 컨트롤러와 비슷한 역할
- Template : 사용자에게 보여질 화면의 구조와 디자인을 정리 

### 결국 중요한 건 관심사의 분리
- 비즈니스 로직의 위치를 어디에 선정하면 좋을까

- 컨트롤러에 비즈니스 로직을 두는 경우 : 간단한 어플리케이션의 경우
- 모델에 비즈니스 로직을 두는 경우 : 모델이 비즈니스 로직을 처리하고, 컨트롤러는 모델의 결과를 받아서 뷰에게 전달하는 역할만 수행
- 컨트롤러와 모델 사이에 두는 경우 : 서비스 계층 (컨트롤러와 모델 사이에 위치)

### Layered Architecture

- 프리젠테이션 - 비즈니스 - 데이터베이스 계층을 각각 독립된 모듈로 개발하고 유지하는 구조

- 외부 요청 처리는 가장 바깥 Presentation Layer에서 처리
- 내부 DB 커넥션 관리는 가장 안쪽 Repository Layer에서 처리  


### 그럼 MVC와 무슨 차이가 있을까?

1. 구조적인 차이 : 선형구조라서 반드시 중간 계층을 거쳐야 , MVC는 삼각형 구조로 서로가 상호작용
2. 범위의 차이 

> MVC 패턴은 Presentation Layer와 Business Layer가 강하게 결합되어 있어서, Presentation Layer의 변경이 Business Layer에 영향을 미칠 수 있다. 

> 반면 Layered Architecture는 Presentation Layer와 Business Layer가 독립적으로 존재하기 때문에, Presentation Layer의 변경이 Business Layer에 영향을 미치지 않는다.


### 백엔드에서 View의 역할은 뭐라고 볼 수 있을까?

- 혁님 : 화면 렌더링 방식에 따라 다르다. 
    - SSR에서는 별로 논의할 내용은 없고, CSR에서는 위임했기 때문에 안보인다. 그렇지만 View에 의존적인 코드가 존재할 수 있다.
- 찬미님 : 스프링 MVC에서는 화면렌더링도 제공하고, 데이터 변환 형식도 제공하기 때문에 그것을 모두 아우르는 것이 뷰라고 볼수 있다(고 영한님이 말씀하심) 

### 비즈니스 로직은 어디에 두고 사용하는지?

- 예성님 : 컨트롤러에 모든 비즈니스로직을 두다보니 코드가 길어지고, 유지보수가 어려워졌다. 프로젝트에 Layered 아키텍쳐를 적용하는 것이 좋을거라고 생각했다.
- 혁님 : MVC 모델 1 방식에서는 JSP에서 뷰도 맡고 비즈니스 로직도 처리했는데, 구현은 쉽지만 유지보수가 어려웠다. 그래서 MVC 모델 2 방식에서는 비즈니스 로직을 서블릿(Controller)에서 처리하고, JSP(View)는 화면 렌더링만 담당하도록 변경했다.  MVC Model2 발전형태는 프론트 컨트롤러가 있다. DispatcherServlet이 그 역할을 한다. Handler Mapping이 처리가능한 컨트롤러를 스캔하고 요청을 전달한다. 그리고 컨트롤러에서 비즈니스 로직을 처리하고, 결과를 모델에 담아서 뷰에 전달한다. 뷰는 모델을 사용해서 화면을 렌더링한다. 데이터 중심의 설계를 하게될 가능성이 높여져서, 도메인 중심 설계를 할 수 있도록 헥사고날 아키텍쳐가 뜨고 있다.  

![mvc 구조](https://terasolunaorg.github.io/guideline/5.0.2.RELEASE/en/_images/RequestLifecycle.png)
- 참고 : https://stdbc.tistory.com/m/20

- 예성님 : 되도록 백엔드에는 뷰처리를 안하려고 한다. 그러나, 장고에서 1차적인 HTML 처리를하고 프론트가 그것을 받아서 해야하는 사례도 있었다!

### 헥사고날 아키텍쳐  

- 혁님 : 도메인 중심 설계를 할 수 있도록 헥사고날 아키텍쳐가 뜨고 있다.  
- 예성님 : 프로젝트에 헥사고날 아키텍쳐를 적용해보니, 작성할 파일이 너무 많아진다. 다 장단점이 있고, 상황에 맞게 적용해야한다. Outbound 포트 추상화에는 유리하다. 단순한 CRUD 서버 코드라면 헥사고날은 오버엔지니어링으로 볼 수도 있을 것 같다. 그치만 하면서 굉장히 재미있었다.  
- 혁님 : 그림일기 서비스를 만들면서 AI Generator(달리 API같은)등의 외부 서비스를 많이 붙여야 할 때, 그에 대한 요청을 추상화해서 비즈니스 로직을 지키는 것도 좋은 방법이라고 생각한다.  
- 찬미님 : 헥사고날을 쓰면 도메인 비즈니스 한 플로우에 대한 테스트 코드를 작성하기 쉬울 것 같다. 
- 혁님 : DDD, MSA와도 자주 엮여서 이야기가 나오는 주제이다. 멀티모듈 아키텍쳐에서도 헥사고날을 많이 사용하는 것 같다. 
멀티모듈과 Monorepo가 유사한 점이 있다. 
- 예성님 : 회사에서 모노레포를 쓸때는 프론트와 백엔드 사이의 유틸이나, 의존성을 공통으로 관리할 수 있어서 좋았다. 
- 혁님 : Member, MemberAdmin, MemberBatch을 모은 멀티모듈 싱글 프로젝트는 코드 중복과 관리가 너무 힘들어 탄생하게 되었다.  
- 예성님 : 해당 구조의 장점은 버전관리를 한꺼번에 할 수 있다는 장점도 있다.  

### 관심사의 분리  

- 혁님 :  컨트롤러에 코드에 집중될 때 테스트 코드 작성이 힘들다. 분리가 잘될 수록 테스트 코드 작성이 쉬워진다. 결국 관심사의 분리를 통해 변경의 영향을 최소화하기 위한 것이다.  

- 예성님 : 기존 코드를 보는데 중요성을 한번더 느꼈다. Strapy는 몽구스 라이브러리를 사용해 이미 포팅을해서 Strapy API로 사용할 수 있도록 되어 있음. 그러나 기존 코드에.. 몽구스를 직접 사용하는 코드가 많았다. 요즘에 고민을 하고 있는 부분이고, Strapy를 버리고 다른 대안(NestJS와 DB에 맞는 ORM을 고려중)을 생각하고 있다. 인덱스나, PK를 자동으로 걸어주지 않는다.  
