---
marp: true
_class: invert
---

# Ch. 09 컴포지트 패턴 (Composite Pattern)

## **컴포지트 패턴**은 
개별 객체와 복합 객체를 동일한 인터페이스로 다루어 일관된 처리를 가능하게 하는 구조 패턴이다.

> `복합객체를 다루는 것과 똑같이 개별객체 다루기`
> `트리 구조로 전체와 부분을 표현하기`
---

## 문제 상황: 메뉴와 서브메뉴 구조
- 레스토랑의 메뉴에는 여러 개의 서브메뉴가 있을 수 있으며, 서브메뉴 안에 또 다른 서브메뉴가 있을 수도 있다.
- 이러한 복잡한 구조를 효과적으로 관리하고 처리하고 싶다.

---

## 해결의 아이디어: 컴포지트 패턴을 이용한 트리 구조
- Menu : MenuComponent 클래스의 내용 구현 + Leaf의 내용 -> 자식들에게 전달 
    - 단일 책임의 원칙을 위배하는 대신 투명성 얻음
```java
public interface MenuComponent {
    void add(MenuComponent menuComponent);
    void remove(MenuComponent menuComponent);
    MenuComponent getChild(int i);
    void print();
}
```
---

---

## 핵심 구성요소

### Component
- 개별 객체와 복합 객체의 공통 인터페이스

### Leaf
- 개별 객체를 나타내는 클래스

### Composite
- 복합 객체를 나타내는 클래스

### Client
- Component 인터페이스를 통해 개별 및 복합 객체를 다루는 클래스

---

## 장점 및 활용

- **계층 구조 표현**: 트리 구조로 복잡한 계층 구조를 표현
- **코드 단순화**: 클라이언트 코드가 개별 객체와 복합 객체를 동일하게 다루므로 단순화
- **확장성**: 새로운 Component 타입을 쉽게 추가 가능
- **재사용성**: 공통 인터페이스를 사용하므로 코드 재사용성 향상

---

## Iterable과 Enhanced For 문

- 컴포지트 패턴은 자바의 `Iterable` 인터페이스와 호환 가능
- Enhanced for 문의 내부동작은 `Iterable.iterator`를 호출한다.

---
```java
public class MyIterableCollection implements Iterable<Integer> {
    private List<String> jjangguList = Arrays.asList("하나", "둘", "셋", "야!");

    @Override
    public Iterator<Integer> iterator() {
        System.out.println("🌟iterator가 호출됨⭐️");
        return jjangguList.iterator();
    }

    public static void main(String[] args) {
        MyIterableCollection collection = new MyIterableCollection();

        for (String string : collection) {
            System.out.println(string);
        }
    }
}
```

---

# 컴포지트 패턴 요약

- 개별 및 복합 객체를 **일관된 방식으로 다룸**
- **트리 구조**로 복잡한 계층 구조 표현
- **설계의 유연성**과 **코드 재사용성** 향상
